/*
 * openshift basic identity
 *
 * openshift basic identity provider
 *
 * API version: 1.0.0
 * Contact: zhu.xiaowei@99cloud.net
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"openshift-basic-identity-provider/db"
	"openshift-basic-identity-provider/helper"
	"openshift-basic-identity-provider/mail"
	"strings"
	"time"

	"github.com/gorilla/mux"
)

func CreateUser(w http.ResponseWriter, r *http.Request) {
	if r.Header["Role"][0] != "admin" {
		helper.ResponseWithJson(w, http.StatusForbidden,
			helper.Response{Code: http.StatusForbidden, Msg: "permission denied"})
		return
	}

	//w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	bodyBytes, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusBadRequest,
			helper.Response{Code: http.StatusBadRequest, Msg: "bad params"})
		return
	}
	bodyString := string(bodyBytes)
	var userinfo db.User
	helper.UnmarshaUp(bodyString, &userinfo)

	if userinfo.Password == "" {
		helper.ResponseWithJson(w, http.StatusBadRequest,
			helper.Response{Code: http.StatusBadRequest, Msg: "bad params"})
		return
	}

	userinfo.Password = db.AesEncrypt(userinfo.Password, *db.SALT_KEY)
	if err := db.DB.Save(&userinfo); err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusInternalServerError,
			helper.Response{Code: http.StatusInternalServerError, Msg: "internal error"})
		return
	}
	//w.WriteHeader(http.StatusOK)
	userinfo.Password = ""
	helper.ResponseWithJson(w, http.StatusOK,
		helper.Response{Code: http.StatusOK, Data: userinfo})
}

func DeleteUser(w http.ResponseWriter, r *http.Request) {
	if r.Header["Role"][0] != "admin" {
		helper.ResponseWithJson(w, http.StatusForbidden,
			helper.Response{Code: http.StatusForbidden, Msg: "permission denied"})
		return
	}
	temp := strings.Split(r.URL.Path, "/")
	username := temp[len(temp)-1]

	if err := db.DB.Delete(&db.User{}, "username=?", username); err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusInternalServerError,
			helper.Response{Code: http.StatusInternalServerError, Msg: "internal error"})
		return
	}
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func ListUsers(w http.ResponseWriter, r *http.Request) {
	//w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	//fmt.Println(r.Header["Isadmin"][0])

	if r.Header["Role"][0] != "admin" {
		helper.ResponseWithJson(w, http.StatusForbidden,
			helper.Response{Code: http.StatusForbidden, Msg: "permission denied"})
		return
	}

	users := []db.User{}
	//query
	if err := db.DB.Find(&users); err != nil && err.Error() != "record not found" {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusInternalServerError,
			helper.Response{Code: http.StatusInternalServerError, Msg: "internal error"})
		return
	}
	for index := range users {
		fmt.Println(users[index].Role)
		users[index].Password = ""
	}

	helper.ResponseWithJson(w, http.StatusOK,
		helper.Response{Code: http.StatusOK, Data: users})
}

func Login(w http.ResponseWriter, r *http.Request) {
	//w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	var userinfo db.User

	auth := strings.Replace(r.Header["Authorization"][0], "Basic ", "", 1)
	credential, _ := base64.StdEncoding.DecodeString(auth)
	userAndPassword := strings.Split(string(credential), ":")
	userAndPassword[1] = db.AesEncrypt(userAndPassword[1], *db.SALT_KEY)

	if err := db.DB.Find(&userinfo, "username =? and password=?", userAndPassword[0], userAndPassword[1]); err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusNotFound,
			helper.Response{Code: http.StatusNotFound, Msg: "the user not exist"})
		return
	}
	token, _ := GenerateToken(&userinfo)
	helper.ResponseWithJson(w, http.StatusOK,
		helper.Response{Code: http.StatusOK, Data: JwtToken{Token: token}})
}

func LoginForOpenshift(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	var userinfo db.User

	auth := strings.Replace(r.Header["Authorization"][0], "Basic ", "", 1)
	credential, _ := base64.StdEncoding.DecodeString(auth)
	userAndPassword := strings.Split(string(credential), ":")
	userAndPassword[1] = db.AesEncrypt(userAndPassword[1], *db.SALT_KEY)

	if err := db.DB.Find(&userinfo, "username =? and password=?", userAndPassword[0], userAndPassword[1]); err != nil {
		log.Printf("%s", err)
		w.WriteHeader(http.StatusUnauthorized)
		_, _ = w.Write(helper.MarshaUp(InlineResponse403{Error_: err.Error()}))
		return
	}

	userinfo.Password = ""
	userinfo.Sub = string(userinfo.ID)
	userinfo.PreferredUsername = userinfo.Name
	userinfo.Username = ""
	w.WriteHeader(http.StatusOK)
	execStatus, err := w.Write(helper.MarshaUp(userinfo))
	if err != nil {
		w.WriteHeader(execStatus)
		// ignore error
		_, _ = w.Write(helper.MarshaUp(InlineResponse403{Error_: err.Error()}))
		return
	}
}

func UpdateUser(w http.ResponseWriter, r *http.Request) {
	//w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	if r.Header["Role"][0] != "admin" {
		helper.ResponseWithJson(w, http.StatusForbidden,
			helper.Response{Code: http.StatusForbidden, Msg: "permission denied"})
		return
	}
	temp := strings.Split(r.URL.Path, "/")
	username := temp[len(temp)-1]
	bodyBytes, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusBadRequest,
			helper.Response{Code: http.StatusBadRequest, Msg: "bad params"})
		return
	}
	bodyString := string(bodyBytes)
	var userinfo db.User
	helper.UnmarshaUp(bodyString, &userinfo)

	if userinfo.Password != "" {
		userinfo.Password = db.AesEncrypt(userinfo.Password, *db.SALT_KEY)
	}

	fmt.Println(username)

	if err := db.DB.Update(&userinfo, "username=?", username); err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusInternalServerError,
			helper.Response{Code: http.StatusInternalServerError, Msg: "internal error"})
		return
	}
	w.WriteHeader(http.StatusOK)
}

func UserInfo(w http.ResponseWriter, r *http.Request) {

	username := r.Header["Username"][0]

	user := db.User{}
	//query
	if err := db.DB.Find(&user, "username =?", username); err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusInternalServerError,
			helper.Response{Code: http.StatusInternalServerError, Msg: err.Error()})
		return
	}
	user.Password = ""

	helper.ResponseWithJson(w, http.StatusOK,
		helper.Response{Code: http.StatusOK, Data: user})
}

func ResetPassword(w http.ResponseWriter, r *http.Request) {
	username := r.Header["Username"][0]

	bodyBytes, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusBadRequest,
			helper.Response{Code: http.StatusBadRequest, Msg: "bad params"})
		return
	}
	bodyString := string(bodyBytes)
	var resetpw db.UpdatePassword
	helper.UnmarshaUp(bodyString, &resetpw)

	user := db.User{}
	//query
	if err := db.DB.Find(&user, "username =?", username); err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusInternalServerError,
			helper.Response{Code: http.StatusInternalServerError, Msg: err.Error()})
		return
	}

	if db.AesEncrypt(resetpw.OldPassword, *db.SALT_KEY) != user.Password {
		helper.ResponseWithJson(w, http.StatusBadRequest,
			helper.Response{Code: http.StatusBadRequest, Msg: "old password is not correct"})
		return
	}

	user.Password = db.AesEncrypt(resetpw.NewPassword, *db.SALT_KEY)

	if err := db.DB.Update(&user, "username=?", username); err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusInternalServerError,
			helper.Response{Code: http.StatusInternalServerError, Msg: "internal error"})
		return
	}
	w.WriteHeader(http.StatusOK)
}

func SendResetPasswordMail(w http.ResponseWriter, r *http.Request) {
	bodyBytes, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusBadRequest,
			helper.Response{Code: http.StatusBadRequest, Msg: "bad params"})
		return
	}
	bodyString := string(bodyBytes)
	var userEmailParam db.UserEmailParam
	helper.UnmarshaUp(bodyString, &userEmailParam)
	user := db.User{}
	if err := db.DB.Find(&user, "email =?", userEmailParam.Email); err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusInternalServerError,
			helper.Response{Code: http.StatusInternalServerError, Msg: "the user not exist"})
		return
	}

	go func() {
		sendMail(&user, "修改密码")
	}()

	w.WriteHeader(http.StatusOK)
}

func MailResetPassword(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id := vars["id"]
	secret := db.UrlAesDecrypt(vars["secret"], *db.SALT_KEY)
	fmt.Println(id)
	fmt.Println(secret)

	bodyBytes, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusBadRequest,
			helper.Response{Code: http.StatusBadRequest, Msg: "bad params"})
		return
	}
	bodyString := string(bodyBytes)
	var resetpw db.MailResetPassword
	helper.UnmarshaUp(bodyString, &resetpw)

	emailTs := strings.Split(secret, "-")
	exp, _ := helper.S(emailTs[0]).Int64()
	now := time.Now().Unix()
	if VerifyExpiresAt(exp, now, false) == false {
		log.Printf("邮箱链接已失效!")
		helper.ResponseWithJson(w, http.StatusBadRequest,
			helper.Response{Code: http.StatusBadRequest, Msg: "邮箱链接已失效!"})
		return
	}

	user := db.User{}
	if err := db.DB.Find(&user, "id =?", id); err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusInternalServerError,
			helper.Response{Code: http.StatusInternalServerError, Msg: err.Error()})
		return
	}
	if user.Email != emailTs[1] {
		helper.ResponseWithJson(w, http.StatusInternalServerError,
			helper.Response{Code: http.StatusInternalServerError, Msg: "用户id与email不匹配"})
		return
	}

	user.Password = db.AesEncrypt(resetpw.Password, *db.SALT_KEY)
	if err := db.DB.Update(&user, "id=?", id); err != nil {
		log.Printf("%s", err)
		helper.ResponseWithJson(w, http.StatusInternalServerError,
			helper.Response{Code: http.StatusInternalServerError, Msg: err.Error()})
		return
	}
	w.WriteHeader(http.StatusOK)
}

func sendMail(user *db.User, title string) {
	exp := time.Now().Add(time.Minute * 30).Unix()
	secretstr := fmt.Sprintf("%d-%s", exp, user.Email)
	fmt.Println(secretstr)
	secretstr = db.UrlAesEncrypt(secretstr, *db.SALT_KEY)
	fmt.Println(secretstr)
	url := fmt.Sprintf("/openshift-basic-identity-provider/1.0.0/reset/verify"+"/%d/%s", user.ID, secretstr)
	fmt.Println(url)

	content := "<p><b>亲爱的" + user.Username + ":</b></p>" +
		"<p>你的密码重设要求已经得到验证。请使用以下api接口重置你的密码，body以{\"password: yourpassword\"}的形式传入新密码! 有效时间为30分钟</p>" +
		"<a href=\"" + url + "\">" + url + "</a>" +
		"<p>感谢你对 99cloud 的支持，希望你在 99cloud-CaaS 的体验有益且愉快。</p>" +
		"<p>(这是一封自动产生的email，请勿回复。)</p>"

	mail.SendMail(user.Email, title, content)
}

func VerifyExpiresAt(exp int64, cmp int64, req bool) bool {
	return verifyExp(exp, cmp, req)
}

func verifyExp(exp int64, now int64, required bool) bool {
	if exp == 0 {
		return !required
	}
	return now <= exp
}
